import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { STLExporter } from 'three/addons/exporters/STLExporter.js';

import {
    parseExpression,
    buildHornMesh
} from './geometry/index.js';

import { ATHConfigParser } from './config/index.js';
import { generateATHConfigContent, exportProfilesCSV, exportGmshGeo } from './export/index.js';
import { saveFile } from './ui/fileOps.js';
import {
    createScene,
    createPerspectiveCamera,
    createOrthoCamera,
    ZebraShader
} from './viewer/index.js';

import { GlobalState } from './state.js';
import { ParamPanel } from './ui/paramPanel.js';
import { AppEvents } from './events.js';

class App {
    constructor() {
        this.container = document.getElementById('canvas-container');
        this.stats = document.getElementById('stats');
        this.renderRequested = false;

        // Init UI
        this.paramPanel = new ParamPanel('param-container');

        this.setupScene();
        this.setupEventListeners();

        // Initial Render
        this.onStateUpdate(GlobalState.get());

        // Subscribe to state updates
        AppEvents.on('state:updated', (state) => {
            this.onStateUpdate(state);
        });
    }

    setupScene() {
        this.scene = createScene();

        this.cameraMode = 'perspective';
        const aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera = createPerspectiveCamera(aspect);

        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.container.appendChild(this.renderer.domElement);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;

        window.addEventListener('resize', () => this.onResize());

        this.animate();
    }

    onResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        const aspect = width / height;

        if (this.cameraMode === 'perspective') {
            this.camera.aspect = aspect;
        } else {
            const size = this.getOrthoSize();
            this.camera.left = -size * aspect;
            this.camera.right = size * aspect;
            this.camera.top = size;
            this.camera.bottom = -size;
        }

        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }

    setupEventListeners() {
        // Global Actions
        document.getElementById('render-btn')?.addEventListener('click', () => this.requestRender());
        document.getElementById('export-btn')?.addEventListener('click', () => this.exportSTL());
        document.getElementById('export-config-btn')?.addEventListener('click', () => this.exportATHConfig());

        // The Model Type selector is now inside ParamPanel, so we don't bind it here explicitly.
        // But if we kept the static one in index.html, we would.
        // Current index.html has cleared params, so likely Model Type is generated by ParamPanel now.

        document.getElementById('display-mode')?.addEventListener('change', () => this.requestRender());

        // Zoom controls
        document.getElementById('zoom-in')?.addEventListener('click', () => this.zoom(0.8));
        document.getElementById('zoom-out')?.addEventListener('click', () => this.zoom(1.2));
        document.getElementById('camera-toggle')?.addEventListener('click', () => this.toggleCamera());
        document.getElementById('zoom-reset')?.addEventListener('click', () => {
            this.controls.reset();
        });
        document.getElementById('focus-horn')?.addEventListener('click', () => this.focusOnModel());

        const loadBtn = document.getElementById('load-config-btn');
        const fileInput = document.getElementById('config-upload');
        if (loadBtn && fileInput) {
            loadBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
        }

        // Profile export buttons
        document.getElementById('export-csv-btn')?.addEventListener('click', () => this.exportProfileCSV());
        document.getElementById('export-geo-btn')?.addEventListener('click', () => this.exportGmshGeo());

        // Undo/Redo keys
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                e.preventDefault();
                if (e.shiftKey) {
                    GlobalState.redo();
                } else {
                    GlobalState.undo();
                }
            }
        });
    }

    onStateUpdate(state) {
        // 1. Rebuild Param UI
        this.paramPanel.createFullPanel();

        // 2. Render
        if (document.getElementById('live-update')?.checked !== false) {
            this.requestRender();
        }
    }

    requestRender() {
        if (!this.renderRequested) {
            this.renderRequested = true;
            requestAnimationFrame(() => {
                this.renderModel();
                this.renderRequested = false;
            });
        }
    }

    toggleModelType(type) {
        // Legacy support function called by legacy listeners if any.
        this.requestRender();
    }

    handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            const parsed = ATHConfigParser.parse(content);
            if (parsed.type) {
                // Convert string values to proper types
                const typedParams = {};
                for (const [key, value] of Object.entries(parsed.params)) {
                    if (value === undefined || value === null) continue;

                    // Check if it's a number
                    const num = parseFloat(value);
                    if (!isNaN(num) && String(num) === String(value).trim()) {
                        typedParams[key] = num;
                    } else {
                        // Keep as string (expressions, etc.)
                        typedParams[key] = String(value);
                    }
                }

                GlobalState.update(typedParams, parsed.type);
            } else {
                alert('Could not find OSSE or R-OSSE block in config file.');
            }
        };
        reader.readAsText(file);
    }

    renderModel() {
        if (this.hornMesh) {
            this.scene.remove(this.hornMesh);
            this.hornMesh.geometry.dispose();
            this.hornMesh.material.dispose();
        }

        const state = GlobalState.get();
        const preparedParams = { ...state.params };

        // Evaluate expressions
        const type = state.type;

        for (const key of Object.keys(preparedParams)) {
            const val = preparedParams[key];
            if (typeof val === 'string' && (val.includes('sin') || val.includes('cos') || val.includes('p') || Number.isNaN(parseFloat(val)))) {
                preparedParams[key] = parseExpression(val);
            }
        }

        preparedParams.type = type;

        const { vertices, indices } = buildHornMesh(preparedParams);

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        const displayMode = document.getElementById('display-mode')?.value || 'standard';
        let material;

        if (displayMode === 'zebra') {
            material = new THREE.ShaderMaterial({
                ...ZebraShader,
                side: THREE.DoubleSide
            });
        } else if (displayMode === 'curvature') {
            // Need segments for curvature
            const ang = preparedParams.angularSegments || 80;
            const len = preparedParams.lengthSegments || 20;
            const colors = this.calculateCurvatureColors(geometry, ang, len);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            material = new THREE.MeshPhongMaterial({ vertexColors: true, side: THREE.DoubleSide });
        } else {
            material = new THREE.MeshPhysicalMaterial({
                color: 0xcccccc,
                metalness: 0.5,
                roughness: 0.3,
                transmission: 0,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                wireframe: displayMode === 'grid'
            });
        }

        this.hornMesh = new THREE.Mesh(geometry, material);
        this.scene.add(this.hornMesh);

        this.stats.innerText = `Vertices: ${vertices.length / 3} | Triangles: ${indices.length / 3}`;
    }

    calculateCurvatureColors(geometry, radialSteps, lengthSteps) {
        const normals = geometry.attributes.normal.array;
        const count = normals.length / 3;
        const colors = new Float32Array(count * 3);

        for (let j = 0; j <= lengthSteps; j++) {
            for (let i = 0; i <= radialSteps; i++) {
                const idx = (j * (radialSteps + 1) + i) * 3;
                let curvature = 0;
                const neighbors = [[j - 1, i], [j + 1, i], [j, i - 1], [j, i + 1]];
                const nx = normals[idx];
                const ny = normals[idx + 1];
                const nz = normals[idx + 2];
                let sampleCount = 0;
                neighbors.forEach(([nj, ni]) => {
                    if (nj >= 0 && nj <= lengthSteps && ni >= 0 && ni <= radialSteps) {
                        const nIdx = (nj * (radialSteps + 1) + ni) * 3;
                        const d = 1.0 - (nx * normals[nIdx] + ny * normals[nIdx + 1] + nz * normals[nIdx + 2]);
                        curvature += d;
                        sampleCount++;
                    }
                });
                const c = Math.min(1.0, (curvature / sampleCount) * 50.0);
                colors[idx] = c;
                colors[idx + 1] = 1 - c;
                colors[idx + 2] = 0.5;
            }
        }
        return colors;
    }

    focusOnModel() {
        if (!this.hornMesh) return;
        this.hornMesh.geometry.computeBoundingBox();
        const box = this.hornMesh.geometry.boundingBox;
        const center = new THREE.Vector3();
        box.getCenter(center);
        this.controls.target.copy(center);
        this.controls.update();
    }

    zoom(factor) {
        if (this.cameraMode === 'perspective') {
            this.camera.position.multiplyScalar(factor);
        } else {
            this.camera.zoom /= factor;
            this.camera.updateProjectionMatrix();
        }
        this.controls.update();
    }

    getOrthoSize() {
        return 300;
    }

    toggleCamera() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        const aspect = width / height;
        const pos = this.camera.position.clone();
        const target = this.controls.target.clone();

        if (this.cameraMode === 'perspective') {
            const size = this.getOrthoSize();
            this.camera = createOrthoCamera(aspect, size);
            this.cameraMode = 'orthographic';
            document.getElementById('camera-toggle').innerText = '▲';
        } else {
            this.camera = createPerspectiveCamera(aspect);
            this.cameraMode = 'perspective';
            document.getElementById('camera-toggle').innerText = '⬚';
        }

        this.camera.position.copy(pos);
        this.scene.add(this.camera);

        const oldControls = this.controls;
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.target.copy(target);
        this.controls.enableDamping = true;
        this.controls.update();
        oldControls.dispose();
    }

    exportSTL() {
        if (!this.hornMesh) return;
        const exporter = new STLExporter();
        const result = exporter.parse(this.hornMesh, { binary: true });

        saveFile(result, 'horn.stl', {
            extension: '.stl',
            contentType: 'application/sla',
            typeInfo: { description: 'STL Model', accept: { 'model/stl': ['.stl'] } }
        });
    }

    exportATHConfig() {
        const state = GlobalState.get();
        const exportParams = { type: state.type, ...state.params };
        const content = generateATHConfigContent(exportParams);
        saveFile(content, 'config.txt', {
            extension: '.txt',
            contentType: 'text/plain',
            typeInfo: { description: 'ATH Config', accept: { 'text/plain': ['.txt'] } }
        });
    }

    exportProfileCSV() {
        if (!this.hornMesh) {
            alert('Please generate a horn model first');
            return;
        }

        const vertices = this.hornMesh.geometry.attributes.position.array;
        const state = GlobalState.get();
        const csv = exportProfilesCSV(vertices, state.params);

        saveFile(csv, 'profiles.csv', {
            extension: '.csv',
            contentType: 'text/csv',
            typeInfo: { description: 'Profile Coordinates', accept: { 'text/csv': ['.csv'] } }
        });
    }

    exportGmshGeo() {
        if (!this.hornMesh) {
            alert('Please generate a horn model first');
            return;
        }

        const vertices = this.hornMesh.geometry.attributes.position.array;
        const state = GlobalState.get();
        const geo = exportGmshGeo(vertices, state.params);

        saveFile(geo, 'mesh.geo', {
            extension: '.geo',
            contentType: 'text/plain',
            typeInfo: { description: 'Gmsh Geometry', accept: { 'text/plain': ['.geo'] } }
        });
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

new App();
