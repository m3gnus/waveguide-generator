/**
 * Gmsh Bridge - Interface between Node.js and Python Gmsh mesher
 * 
 * This module provides functions to generate geometry definitions and
 * invoke the Python Gmsh script to generate high-quality meshes.
 */

import { spawn } from 'child_process';
import { writeFileSync, readFileSync, unlinkSync, existsSync } from 'fs';
import { join } from 'path';

/**
 * Generate Gmsh .geo script from horn geometry
 * 
 * @param {Object} params - Horn parameters
 * @param {Array} profileStations - Array of profile rings [{y, points: [{x, z}]}]
 * @returns {string} Gmsh .geo script content
 */
export function generateGeoScript(params, profileStations) {
    const lines = [];
    
    lines.push('// MWG Horn Geometry - Generated by MWG');
    lines.push('// Gmsh .geo script');
    lines.push('');
    
    // Set meshing parameters
    const meshSize = params.meshSize || 2.0;
    lines.push(`Mesh.CharacteristicLengthMin = ${meshSize * 0.5};`);
    lines.push(`Mesh.CharacteristicLengthMax = ${meshSize * 2.0};`);
    lines.push(`Mesh.Algorithm = 6; // Frontal-Delaunay`);
    lines.push('');
    
    // Generate points for each station
    let pointId = 1;
    const stationPoints = [];
    
    for (let s = 0; s < profileStations.length; s++) {
        const station = profileStations[s];
        const y = station.y;
        const points = [];
        
        for (const pt of station.points) {
            lines.push(`Point(${pointId}) = {${pt.x}, ${y}, ${pt.z}, ${meshSize}};`);
            points.push(pointId);
            pointId++;
        }
        
        stationPoints.push(points);
    }
    
    lines.push('');
    
    // Generate curves (splines through points at each station)
    let curveId = 1;
    const stationCurves = [];
    
    for (const points of stationPoints) {
        // Create closed curve loop
        const curves = [];
        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            lines.push(`Line(${curveId}) = {${p1}, ${p2}};`);
            curves.push(curveId);
            curveId++;
        }
        stationCurves.push(curves);
    }
    
    lines.push('');
    
    // Generate curve loops and surfaces
    let loopId = 1;
    let surfaceId = 1;
    
    for (const curves of stationCurves) {
        lines.push(`Curve Loop(${loopId}) = {${curves.join(', ')}};`);
        lines.push(`Plane Surface(${surfaceId}) = {${loopId}};`);
        loopId++;
        surfaceId++;
    }
    
    lines.push('');
    
    // Generate ruled surfaces between stations (lofting)
    for (let s = 0; s < stationCurves.length - 1; s++) {
        const curves1 = stationCurves[s];
        const curves2 = stationCurves[s + 1];
        
        // Connect corresponding edges
        for (let i = 0; i < curves1.length; i++) {
            const c1 = curves1[i];
            const c2 = curves2[i];
            lines.push(`Ruled Surface(${surfaceId}) = {${c1}, ${c2}};`);
            surfaceId++;
        }
    }
    
    return lines.join('\n');
}

/**
 * Convert mesh geometry to Gmsh-compatible profile stations
 * 
 * @param {Float32Array} vertices - Vertex array from buildHornMesh
 * @param {Object} params - Parameters used to generate mesh
 * @returns {Array} Array of profile stations
 */
export function extractProfileStations(vertices, params) {
    // Extract unique Y positions (stations)
    const yPositions = new Set();
    for (let i = 1; i < vertices.length; i += 3) {
        yPositions.add(vertices[i]);
    }
    
    const sortedY = Array.from(yPositions).sort((a, b) => a - b);
    
    // Group points by Y position
    const stations = sortedY.map(y => {
        const points = [];
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const vy = vertices[i + 1];
            const z = vertices[i + 2];
            
            if (Math.abs(vy - y) < 0.001) {
                points.push({ x, z });
            }
        }
        return { y, points };
    });
    
    return stations;
}

/**
 * Call Python Gmsh script to generate mesh
 * 
 * @param {string} geoContent - Gmsh .geo script content
 * @param {string} outputPath - Output .msh file path
 * @param {Object} options - Meshing options
 * @returns {Promise<Object>} Mesh statistics
 */
export async function generateMesh(geoContent, outputPath, options = {}) {
    const {
        elementSize = 2.0,
        algorithm = 6,
        optimize = true,
        format = 'msh' // 'msh', 'stl', 'vtk'
    } = options;
    
    // Write .geo file to temp location in output directory (more reliable than /tmp)
    const tempGeo = join(process.cwd(), 'output', `mwg_temp_${Date.now()}.geo`);
    
    try {
        writeFileSync(tempGeo, geoContent, 'utf8');
        console.log(`Wrote .geo file to: ${tempGeo}`);
        
        // Verify file was written
        if (!existsSync(tempGeo)) {
            throw new Error(`Failed to write .geo file to ${tempGeo}`);
        }
        console.log(`Verified .geo file exists (${geoContent.length} bytes)`);
        
        // Call Python Gmsh script
        const scriptPath = join(process.cwd(), 'scripts', 'gmsh_mesher.py');
        const args = [
            scriptPath,
            tempGeo,
            outputPath,
            '--element-size', elementSize.toString(),
            '--algorithm', algorithm.toString()
        ];
        
        if (!optimize) {
            args.push('--no-optimize');
        }
        
        return new Promise((resolve, reject) => {
            const proc = spawn('python3', args);
            
            let stdout = '';
            let stderr = '';
            
            proc.stdout.on('data', (data) => {
                stdout += data.toString();
            });
            
            proc.stderr.on('data', (data) => {
                stderr += data.toString();
            });
            
            proc.on('close', (code) => {
                // Cleanup temp file after process completes
                try {
                    unlinkSync(tempGeo);
                } catch (e) {
                    // Ignore cleanup errors
                }
                
                if (code === 0) {
                    console.log(stdout);
                    resolve({
                        success: true,
                        output: stdout,
                        path: outputPath
                    });
                } else {
                    reject(new Error(`Gmsh failed with code ${code}: ${stderr}`));
                }
            });
            
            proc.on('error', (err) => {
                // Cleanup on error too
                try {
                    unlinkSync(tempGeo);
                } catch (e) {
                    // Ignore cleanup errors
                }
                reject(err);
            });
        });
        
    } catch (error) {
        // Cleanup on error during setup
        try {
            if (existsSync(tempGeo)) {
                unlinkSync(tempGeo);
            }
        } catch (e) {
            // Ignore cleanup errors
        }
        throw error;
    }
}

/**
 * High-level function to mesh horn geometry using Gmsh
 * 
 * @param {Object} params - Horn parameters
 * @param {Float32Array} vertices - Current mesh vertices
 * @param {string} outputPath - Output file path
 * @param {Object} options - Meshing options
 * @returns {Promise<Object>} Mesh result
 */
export async function meshHornWithGmsh(params, vertices, outputPath, options = {}) {
    console.log('Extracting profile stations from geometry...');
    const stations = extractProfileStations(vertices, params);
    
    console.log(`Found ${stations.length} stations`);
    
    console.log('Generating Gmsh .geo script...');
    const geoScript = generateGeoScript(params, stations);
    
    console.log('Invoking Gmsh mesher...');
    const result = await generateMesh(geoScript, outputPath, options);
    
    return result;
}

/**
 * Remesh an STL file using Gmsh
 * 
 * This is simpler and more robust than generating .geo scripts.
 * Takes an existing STL, lets Gmsh classify surfaces and remesh with optimization.
 * 
 * @param {string} stlPath - Input STL file path
 * @param {string} outputPath - Output mesh file path (.msh, .stl, .vtk)
 * @param {Object} options - Meshing options
 * @returns {Promise<Object>} Mesh result
 */
export async function remeshSTL(stlPath, outputPath, options = {}) {
    const {
        elementSize = 2.0,
        algorithm = 6,
        optimize = true,
        format = 'msh'
    } = options;
    
    // Verify input file exists
    if (!existsSync(stlPath)) {
        throw new Error(`Input STL file not found: ${stlPath}`);
    }
    
    console.log(`Remeshing STL with Gmsh...`);
    console.log(`  Input: ${stlPath}`);
    console.log(`  Output: ${outputPath}`);
    console.log(`  Element size: ${elementSize}`);
    
    // Call Python Gmsh script directly with STL input
    const scriptPath = join(process.cwd(), 'scripts', 'gmsh_mesher.py');
    const args = [
        scriptPath,
        stlPath,
        outputPath,
        '--element-size', elementSize.toString(),
        '--algorithm', algorithm.toString()
    ];
    
    if (!optimize) {
        args.push('--no-optimize');
    }
    
    return new Promise((resolve, reject) => {
        const proc = spawn('python3', args);
        
        let stdout = '';
        let stderr = '';
        
        proc.stdout.on('data', (data) => {
            const text = data.toString();
            stdout += text;
            // Echo output in real-time
            process.stdout.write(text);
        });
        
        proc.stderr.on('data', (data) => {
            stderr += data.toString();
        });
        
        proc.on('close', (code) => {
            if (code === 0) {
                resolve({
                    success: true,
                    output: stdout,
                    path: outputPath,
                    inputPath: stlPath
                });
            } else {
                reject(new Error(`Gmsh remeshing failed with code ${code}: ${stderr}`));
            }
        });
        
        proc.on('error', (err) => {
            reject(err);
        });
    });
}
